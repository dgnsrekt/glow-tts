# Bubble Tea TUI Standards

> Best practices for building Terminal User Interfaces with Bubble Tea
> Focused on maintainable, responsive, and elegant TUI applications

## Architecture Principles

### The Elm Architecture
Bubble Tea follows the Elm Architecture pattern:
1. **Model** - Application state
2. **View** - Render state to screen
3. **Update** - Handle messages and update state

```go
type model struct {
    // Application state
    content  string
    cursor   int
    viewport viewport.Model
}

func (m model) Init() tea.Cmd {
    // Initial commands
    return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    // Handle messages
    return m, nil
}

func (m model) View() string {
    // Render UI
    return ""
}
```

## Message Design

### Message Types
```go
// Command results
type contentLoadedMsg struct {
    content string
    err     error
}

// User actions
type itemSelectedMsg int

// System events
type windowSizeMsg struct {
    width  int
    height int
}

// Status updates
type statusMsg struct {
    text    string
    timeout time.Duration
}
```

### Message Conventions
- **Suffix with "Msg"** for clarity
- **Include error field** when operations can fail
- **Keep messages immutable**
- **Use structs over primitives** for extensibility

```go
// Good
type audioPlaybackStartedMsg struct {
    sentence string
    duration time.Duration
}

// Avoid
type stringMsg string  // Too generic
```

## State Management

### Model Structure
```go
type model struct {
    // Core state
    state  applicationState
    ready  bool
    
    // Sub-models
    viewport viewport.Model
    list     list.Model
    help     help.Model
    
    // Data
    items    []Item
    selected int
    
    // UI state
    width    int
    height   int
    err      error
}
```

### State Transitions
```go
type applicationState int

const (
    stateLoading applicationState = iota
    stateBrowsing
    stateViewing
    stateError
)

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch m.state {
    case stateLoading:
        return m.handleLoadingUpdate(msg)
    case stateBrowsing:
        return m.handleBrowsingUpdate(msg)
    // ...
    }
}
```

### Immutable Updates
```go
// Always return new model
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    var cmd tea.Cmd
    
    switch msg := msg.(type) {
    case tea.KeyMsg:
        switch msg.String() {
        case "up":
            m.cursor-- // Update copy
            if m.cursor < 0 {
                m.cursor = 0
            }
        }
    }
    
    return m, cmd  // Return modified copy
}
```

## Command Patterns

### Command Composition
```go
// Batch multiple commands
func (m model) Init() tea.Cmd {
    return tea.Batch(
        loadContent(),
        watchFileSystem(),
        tea.EnterAltScreen,
    )
}

// Sequential commands
func loadAndProcess() tea.Cmd {
    return tea.Sequence(
        loadFile(),
        processContent(),
        updateDisplay(),
    )
}
```

### Async Operations
```go
func fetchMarkdown(url string) tea.Cmd {
    return func() tea.Msg {
        resp, err := http.Get(url)
        if err != nil {
            return errMsg{err}
        }
        defer resp.Body.Close()
        
        content, err := io.ReadAll(resp.Body)
        if err != nil {
            return errMsg{err}
        }
        
        return contentMsg{string(content)}
    }
}
```

### Background Tasks
```go
func watchForChanges(path string) tea.Cmd {
    return func() tea.Msg {
        sub := make(chan fileChangeMsg)
        
        go func() {
            // Watch for file changes
            for change := range watcher {
                sub <- fileChangeMsg{change}
            }
        }()
        
        return sub  // Return channel as subscription
    }
}
```

## Component Organization

### Sub-Model Pattern
```go
// Parent model embeds child models
type model struct {
    pager  pagerModel
    stash  stashModel
    active component
}

// Delegate updates to active component
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch m.active {
    case pagerComponent:
        newPager, cmd := m.pager.Update(msg)
        m.pager = newPager
        return m, cmd
    case stashComponent:
        newStash, cmd := m.stash.Update(msg)
        m.stash = newStash
        return m, cmd
    }
    return m, nil
}
```

### Shared State
```go
// Common configuration
type commonModel struct {
    width   int
    height  int
    theme   Theme
    config  Config
}

// Embed in components
type pagerModel struct {
    commonModel
    content  string
    viewport viewport.Model
}

type stashModel struct {
    commonModel
    items []Item
    list  list.Model
}
```

## View Rendering

### Efficient Rendering
```go
func (m model) View() string {
    if !m.ready {
        return "Loading..."
    }
    
    // Build view with strings.Builder for performance
    var b strings.Builder
    
    // Header
    b.WriteString(m.headerView())
    b.WriteString("\n")
    
    // Content
    switch m.state {
    case stateBrowsing:
        b.WriteString(m.listView())
    case stateViewing:
        b.WriteString(m.contentView())
    }
    
    // Footer
    b.WriteString("\n")
    b.WriteString(m.footerView())
    
    return b.String()
}
```

### Styling with Lipgloss
```go
var (
    titleStyle = lipgloss.NewStyle().
        Bold(true).
        Foreground(lipgloss.Color("205"))
    
    selectedStyle = lipgloss.NewStyle().
        Background(lipgloss.Color("62")).
        Foreground(lipgloss.Color("230"))
)

func (m model) renderItem(item Item, selected bool) string {
    style := normalStyle
    if selected {
        style = selectedStyle
    }
    return style.Render(item.Title)
}
```

### Responsive Layout
```go
func (m model) View() string {
    // Adjust for terminal size
    availableHeight := m.height - headerHeight - footerHeight
    
    content := m.viewport.View()
    
    // Truncate or pad as needed
    if lipgloss.Height(content) > availableHeight {
        content = truncate(content, availableHeight)
    }
    
    return lipgloss.JoinVertical(
        lipgloss.Top,
        m.headerView(),
        content,
        m.footerView(),
    )
}
```

## Key Handling

### Key Bindings
```go
type keyMap struct {
    Up       key.Binding
    Down     key.Binding
    Enter    key.Binding
    Back     key.Binding
    Quit     key.Binding
    Help     key.Binding
}

var defaultKeyMap = keyMap{
    Up: key.NewBinding(
        key.WithKeys("up", "k"),
        key.WithHelp("↑/k", "up"),
    ),
    Down: key.NewBinding(
        key.WithKeys("down", "j"),
        key.WithHelp("↓/j", "down"),
    ),
    // ...
}
```

### Context-Aware Keys
```go
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        // Different keys for different states
        switch m.state {
        case stateBrowsing:
            return m.handleBrowsingKeys(msg)
        case stateViewing:
            return m.handleViewingKeys(msg)
        }
    }
    return m, nil
}
```

## Performance Optimization

### Viewport Management
```go
// Use viewport for large content
func (m model) Init() tea.Cmd {
    m.viewport = viewport.New(m.width, m.height)
    m.viewport.SetContent(m.content)
    return nil
}

// Update viewport on resize
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.WindowSizeMsg:
        m.viewport.Width = msg.Width
        m.viewport.Height = msg.Height - headerHeight - footerHeight
    }
    
    var cmd tea.Cmd
    m.viewport, cmd = m.viewport.Update(msg)
    return m, cmd
}
```

### Lazy Loading
```go
// Load content on demand
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case itemSelectedMsg:
        if !m.items[msg.index].loaded {
            return m, loadItemContent(msg.index)
        }
    }
    return m, nil
}
```

### Debouncing
```go
var searchDebounce = time.Millisecond * 300

func debounceSearch(query string) tea.Cmd {
    return tea.Tick(searchDebounce, func(t time.Time) tea.Msg {
        return searchMsg{query: query}
    })
}
```

## Error Handling

### User-Friendly Errors
```go
type errMsg struct{ err error }

func (e errMsg) Error() string { return e.err.Error() }

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case errMsg:
        m.err = msg.err
        m.state = stateError
        // Auto-clear after timeout
        return m, tea.Tick(5*time.Second, func(t time.Time) tea.Msg {
            return clearErrorMsg{}
        })
    }
    return m, nil
}

func (m model) View() string {
    if m.err != nil {
        return errorStyle.Render(
            fmt.Sprintf("Error: %v\nPress any key to continue...", m.err),
        )
    }
    // Regular view
}
```

## Testing Strategies

### Model Testing
```go
func TestModelUpdate(t *testing.T) {
    m := initialModel()
    
    // Test key press
    newModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyDown})
    
    assert.Equal(t, 1, newModel.(model).cursor)
    assert.Nil(t, cmd)
}
```

### Message Testing
```go
func TestLoadContent(t *testing.T) {
    // Test command
    cmd := loadContent("test.md")
    msg := cmd()
    
    switch m := msg.(type) {
    case contentLoadedMsg:
        assert.NoError(t, m.err)
        assert.Contains(t, m.content, "expected")
    default:
        t.Fatalf("unexpected message type: %T", msg)
    }
}
```

## Mouse Support

### Enable Mouse
```go
func main() {
    p := tea.NewProgram(
        initialModel(),
        tea.WithAltScreen(),
        tea.WithMouseCellMotion(),  // Track mouse movement
    )
}
```

### Handle Mouse Events
```go
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.MouseMsg:
        switch msg.Type {
        case tea.MouseWheelUp:
            m.viewport.LineUp(3)
        case tea.MouseWheelDown:
            m.viewport.LineDown(3)
        case tea.MouseLeft:
            m.handleClick(msg.X, msg.Y)
        }
    }
    return m, nil
}
```

## Common Patterns

### Status Messages
```go
func (m model) setStatus(text string) (model, tea.Cmd) {
    m.statusText = text
    return m, tea.Tick(3*time.Second, func(t time.Time) tea.Msg {
        return clearStatusMsg{}
    })
}
```

### Progress Indicators
```go
type progressMsg float64

func trackProgress() tea.Cmd {
    return func() tea.Msg {
        for progress := 0.0; progress <= 1.0; progress += 0.1 {
            time.Sleep(100 * time.Millisecond)
            return progressMsg(progress)
        }
        return progressCompleteMsg{}
    }
}
```

### File Picker
```go
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        if msg.String() == "o" {
            return m, selectFile()
        }
    }
    return m, nil
}

func selectFile() tea.Cmd {
    return func() tea.Msg {
        file, err := openFileDialog()
        if err != nil {
            return errMsg{err}
        }
        return fileSelectedMsg{path: file}
    }
}
```

---

*Build elegant, responsive TUIs with these Bubble Tea patterns.*
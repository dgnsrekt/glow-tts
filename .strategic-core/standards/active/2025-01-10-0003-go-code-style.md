# Go Code Style Standards

> Idiomatic Go patterns and conventions for consistent, maintainable code
> Based on effective Go and community best practices

## Code Formatting

### Automated Formatting
- **Always use `gofmt`** - No exceptions
- **Use `goimports`** for import organization
- **Configure editor** to format on save

```bash
# Format all files
gofmt -w .
goimports -w .

# Or use go fmt (wraps gofmt)
go fmt ./...
```

### golangci-lint Configuration
```yaml
# .golangci.yml
linters:
  enable:
    - gofmt
    - goimports
    - govet
    - errcheck
    - staticcheck
    - gosimple
    - ineffassign
    - unused
    - misspell
```

## Naming Conventions

### Package Names
- **Lowercase, single word** preferred
- **No underscores or mixedCaps**
- **Short and descriptive**

```go
// Good
package tts
package audio
package config

// Bad
package tts_engine
package TTSEngine
package text_to_speech_processor
```

### Interface Names
- **Single method interfaces** use -er suffix
- **Multiple methods** use descriptive names
- **No "I" prefix**

```go
// Good
type Reader interface { Read([]byte) (int, error) }
type TTSEngine interface { ... }

// Bad
type IReader interface { ... }
type ReaderInterface interface { ... }
```

### Variable Names
- **Short names for short scopes**
- **Descriptive names for exported items**
- **Use camelCase, not snake_case**

```go
// Good
for i := 0; i < 10; i++ { ... }
var audioBuffer []byte
var sentenceQueue *Queue

// Bad
for index := 0; index < 10; index++ { ... }
var audio_buffer []byte
var q *Queue  // too short for package scope
```

## Error Handling

### Error Checking
- **Check errors immediately**
- **Handle or return, don't ignore**
- **Add context when wrapping**

```go
// Good
data, err := os.ReadFile(path)
if err != nil {
    return fmt.Errorf("reading config file: %w", err)
}

// Bad
data, _ := os.ReadFile(path)  // Never ignore errors
```

### Error Types
```go
// Sentinel errors
var (
    ErrNotFound = errors.New("not found")
    ErrInvalidInput = errors.New("invalid input")
)

// Custom error types
type TTSError struct {
    Engine string
    Err    error
}

func (e *TTSError) Error() string {
    return fmt.Sprintf("TTS engine %s: %v", e.Engine, e.Err)
}

func (e *TTSError) Unwrap() error {
    return e.Err
}
```

### Error Messages
- **Lowercase** (unless proper noun)
- **No punctuation** at the end
- **Add context** from inner to outer

```go
// Good
return fmt.Errorf("parsing sentence at position %d: %w", pos, err)

// Bad
return fmt.Errorf("Error parsing sentence!: %w", err)
```

## Function Design

### Function Signatures
- **Limit parameters** (ideally < 4)
- **Group related parameters** in structs
- **Return error last**

```go
// Good
func ProcessAudio(ctx context.Context, opts AudioOptions) (*Audio, error)

// Avoid
func ProcessAudio(format string, rate int, channels int, buffer []byte, timeout time.Duration) (*Audio, error)
```

### Receiver Names
- **Short, typically one letter**
- **Consistent throughout type**
- **Not "self" or "this"**

```go
// Good
func (c *Controller) Start() error { ... }
func (c *Controller) Stop() error { ... }

// Bad
func (self *Controller) Start() error { ... }
func (ctrl *Controller) Stop() error { ... }
```

## Concurrency Patterns

### Goroutine Management
```go
// Always handle goroutine lifecycle
type Service struct {
    done chan struct{}
    wg   sync.WaitGroup
}

func (s *Service) Start() {
    s.wg.Add(1)
    go func() {
        defer s.wg.Done()
        s.run()
    }()
}

func (s *Service) Stop() {
    close(s.done)
    s.wg.Wait()
}
```

### Channel Conventions
- **Make channels** in the goroutine that writes
- **Receive channels** as parameters
- **Use directional channels** in APIs

```go
// Good
func producer() <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        // produce values
    }()
    return ch
}

func consumer(ch <-chan int) {
    for val := range ch {
        // consume values
    }
}
```

### Context Usage
- **First parameter** in functions
- **Named ctx** not context
- **Pass through** the call chain

```go
func ProcessSentence(ctx context.Context, s string) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        // process
    }
}
```

## Project Structure

### Standard Layout
```
glow-tts/
├── cmd/           # Main applications
├── internal/      # Private packages
│   ├── tts/      # TTS engine implementations
│   ├── audio/    # Audio processing
│   └── queue/    # Queue management
├── pkg/          # Public packages (if any)
├── ui/           # UI components
├── go.mod
├── go.sum
└── main.go
```

### Package Organization
- **One package per directory**
- **Related files in same package**
- **Test files alongside code**
- **Internal for private packages**

## Comments and Documentation

### Package Comments
```go
// Package tts provides text-to-speech functionality for the Glow
// markdown reader. It supports multiple TTS engines and manages
// audio playback through a background service.
package tts
```

### Exported Items
```go
// TTSEngine defines the interface for text-to-speech engines.
// Implementations must be safe for concurrent use.
type TTSEngine interface {
    // Synthesize converts text to audio data.
    // Returns an error if synthesis fails.
    Synthesize(text string) ([]byte, error)
}
```

### Implementation Comments
```go
// Why, not what
// Bad: increment i
i++

// Good: Skip header row
i++
```

## Testing Conventions

### Test File Naming
- **Suffix with _test.go**
- **Same package** for white-box tests
- **Package with _test** suffix for black-box

```go
// audio.go -> audio_test.go
// Package internal tests
package audio

// Package external tests
package audio_test
```

### Test Function Naming
```go
func TestEngine_Synthesize(t *testing.T) { ... }
func TestQueue_Enqueue_WhenFull(t *testing.T) { ... }
func BenchmarkAudioProcessing(b *testing.B) { ... }
```

## Dependencies

### Module Management
```bash
# Initialize module
go mod init github.com/user/glow-tts

# Add dependencies
go get github.com/charmbracelet/bubbletea

# Clean up
go mod tidy

# Vendor (optional)
go mod vendor
```

### Import Organization
```go
import (
    // Standard library
    "context"
    "fmt"
    
    // External packages
    "github.com/charmbracelet/bubbletea"
    
    // Internal packages
    "github.com/user/glow-tts/internal/tts"
)
```

## Performance Guidelines

### Avoid Allocations
```go
// Reuse buffers
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

// Preallocate slices
items := make([]Item, 0, expectedSize)
```

### String Building
```go
// For multiple concatenations
var sb strings.Builder
sb.WriteString("hello")
sb.WriteString(" world")
result := sb.String()

// Not for small, fixed concatenations
result := "hello" + " world"  // This is fine
```

## Common Patterns

### Functional Options
```go
type Option func(*Config)

func WithTimeout(d time.Duration) Option {
    return func(c *Config) {
        c.Timeout = d
    }
}

func NewService(opts ...Option) *Service {
    cfg := defaultConfig()
    for _, opt := range opts {
        opt(cfg)
    }
    return &Service{config: cfg}
}
```

### Builder Pattern
```go
type AudioBuilder struct {
    format   string
    rate     int
    channels int
}

func (b *AudioBuilder) Format(f string) *AudioBuilder {
    b.format = f
    return b
}

func (b *AudioBuilder) Build() (*Audio, error) {
    // validate and build
}
```

## Linting and Tools

### Required Tools
```bash
# Install
go install golang.org/x/tools/cmd/goimports@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Run before commit
goimports -w .
golangci-lint run
go test ./...
```

### Pre-commit Hook
```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: go-fmt
        name: go fmt
        entry: go fmt ./...
        language: system
        pass_filenames: false
      - id: go-lint
        name: golangci-lint
        entry: golangci-lint run
        language: system
        pass_filenames: false
```

---

*Follow these patterns for idiomatic, maintainable Go code.*
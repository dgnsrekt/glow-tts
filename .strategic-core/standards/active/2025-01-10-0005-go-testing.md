# Go Testing Standards

> Comprehensive testing strategies for Go applications
> Focus on TTS, audio processing, and TUI components

## Testing Philosophy

### Testing Pyramid
1. **Unit Tests** (70%) - Fast, isolated, numerous
2. **Integration Tests** (20%) - Component interactions
3. **End-to-End Tests** (10%) - Critical user paths

### Coverage Goals
- **Minimum 80%** overall coverage
- **Critical paths 100%** (TTS engines, audio playback)
- **UI components 60%** (harder to test)
- **Error paths 90%** (especially important)

## Table-Driven Tests

### Basic Pattern
```go
func TestSentenceParser(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected []string
        wantErr  bool
    }{
        {
            name:     "simple sentence",
            input:    "Hello world.",
            expected: []string{"Hello world."},
            wantErr:  false,
        },
        {
            name:     "multiple sentences",
            input:    "First. Second. Third.",
            expected: []string{"First.", "Second.", "Third."},
            wantErr:  false,
        },
        {
            name:     "with markdown",
            input:    "This is **bold** text.",
            expected: []string{"This is bold text."},
            wantErr:  false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ParseSentences(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("ParseSentences() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.expected) {
                t.Errorf("ParseSentences() = %v, want %v", got, tt.expected)
            }
        })
    }
}
```

### Complex Test Cases
```go
func TestTTSEngine_Synthesize(t *testing.T) {
    type fields struct {
        config  Config
        cache   Cache
        running bool
    }
    type args struct {
        ctx  context.Context
        text string
    }
    tests := []struct {
        name    string
        fields  fields
        args    args
        want    []byte
        wantErr bool
        setup   func(*testing.T, *fields)
        cleanup func(*testing.T)
    }{
        {
            name: "synthesize with cache hit",
            fields: fields{
                config:  defaultConfig(),
                cache:   NewMemoryCache(),
                running: true,
            },
            args: args{
                ctx:  context.Background(),
                text: "Hello world",
            },
            want:    []byte("cached_audio_data"),
            wantErr: false,
            setup: func(t *testing.T, f *fields) {
                f.cache.Set("Hello world", []byte("cached_audio_data"))
            },
        },
        // More test cases...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if tt.setup != nil {
                tt.setup(t, &tt.fields)
            }
            if tt.cleanup != nil {
                defer tt.cleanup(t)
            }

            e := &TTSEngine{
                config:  tt.fields.config,
                cache:   tt.fields.cache,
                running: tt.fields.running,
            }
            
            got, err := e.Synthesize(tt.args.ctx, tt.args.text)
            if (err != nil) != tt.wantErr {
                t.Errorf("Synthesize() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !bytes.Equal(got, tt.want) {
                t.Errorf("Synthesize() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

## Mock Interfaces

### Interface Design for Testing
```go
// Define interfaces for external dependencies
type TTSEngine interface {
    Synthesize(ctx context.Context, text string) ([]byte, error)
    GetVoices() []Voice
    SetVoice(voice Voice) error
}

type AudioPlayer interface {
    Play(data []byte) error
    Stop() error
    IsPlaying() bool
}

type FileSystem interface {
    ReadFile(path string) ([]byte, error)
    WriteFile(path string, data []byte) error
    Exists(path string) bool
}
```

### Mock Implementation
```go
// mock_tts.go
type MockTTSEngine struct {
    SynthesizeFunc func(ctx context.Context, text string) ([]byte, error)
    GetVoicesFunc  func() []Voice
    SetVoiceFunc   func(voice Voice) error
    
    // Track calls for assertions
    SynthesizeCalls []struct {
        Ctx  context.Context
        Text string
    }
}

func (m *MockTTSEngine) Synthesize(ctx context.Context, text string) ([]byte, error) {
    m.SynthesizeCalls = append(m.SynthesizeCalls, struct {
        Ctx  context.Context
        Text string
    }{ctx, text})
    
    if m.SynthesizeFunc != nil {
        return m.SynthesizeFunc(ctx, text)
    }
    return []byte("mock_audio"), nil
}
```

### Using Mocks in Tests
```go
func TestController_ProcessDocument(t *testing.T) {
    // Create mock
    mockEngine := &MockTTSEngine{
        SynthesizeFunc: func(ctx context.Context, text string) ([]byte, error) {
            if text == "error" {
                return nil, errors.New("synthesis failed")
            }
            return []byte("audio_" + text), nil
        },
    }
    
    mockPlayer := &MockAudioPlayer{
        PlayFunc: func(data []byte) error {
            return nil
        },
    }
    
    // Create controller with mocks
    controller := NewController(mockEngine, mockPlayer)
    
    // Test
    err := controller.ProcessDocument("Hello. World.")
    assert.NoError(t, err)
    
    // Verify calls
    assert.Len(t, mockEngine.SynthesizeCalls, 2)
    assert.Equal(t, "Hello.", mockEngine.SynthesizeCalls[0].Text)
    assert.Equal(t, "World.", mockEngine.SynthesizeCalls[1].Text)
}
```

## Integration Testing

### Testing with Real Components
```go
// integration_test.go
// +build integration

func TestTTSPipeline_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    // Create real components
    engine := NewPiperEngine(PiperConfig{
        ModelPath: "test_model.onnx",
    })
    defer engine.Close()
    
    player := NewAudioPlayer()
    defer player.Close()
    
    controller := NewController(engine, player)
    
    // Test real workflow
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    err := controller.ProcessText(ctx, "Hello, this is a test.")
    assert.NoError(t, err)
    
    // Wait for playback to complete
    assert.Eventually(t, func() bool {
        return !player.IsPlaying()
    }, 10*time.Second, 100*time.Millisecond)
}
```

### Database Testing
```go
func TestCache_Database(t *testing.T) {
    // Use test database
    db := setupTestDB(t)
    defer cleanupTestDB(t, db)
    
    cache := NewDatabaseCache(db)
    
    // Test operations
    err := cache.Set("key", []byte("value"))
    assert.NoError(t, err)
    
    value, exists := cache.Get("key")
    assert.True(t, exists)
    assert.Equal(t, []byte("value"), value)
}

func setupTestDB(t *testing.T) *sql.DB {
    db, err := sql.Open("sqlite3", ":memory:")
    require.NoError(t, err)
    
    // Run migrations
    err = runMigrations(db)
    require.NoError(t, err)
    
    return db
}
```

## Benchmark Testing

### Basic Benchmarks
```go
func BenchmarkSentenceParser(b *testing.B) {
    text := strings.Repeat("This is a sentence. ", 100)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = ParseSentences(text)
    }
}

func BenchmarkAudioBuffer(b *testing.B) {
    buffer := NewRingBuffer(1024 * 1024) // 1MB
    data := make([]byte, 4096)           // 4KB chunks
    
    b.Run("Write", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            buffer.Write(data)
        }
    })
    
    b.Run("Read", func(b *testing.B) {
        // Fill buffer first
        for i := 0; i < 256; i++ {
            buffer.Write(data)
        }
        
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            buffer.Read(data)
        }
    })
}
```

### Memory Benchmarks
```go
func BenchmarkTTSEngine_Memory(b *testing.B) {
    engine := NewMockEngine()
    text := "This is a test sentence for memory benchmarking."
    
    b.ReportAllocs()
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        audio, _ := engine.Synthesize(context.Background(), text)
        _ = audio
    }
}
```

### Parallel Benchmarks
```go
func BenchmarkConcurrentSynthesis(b *testing.B) {
    engine := NewMockEngine()
    texts := []string{
        "First sentence.",
        "Second sentence.",
        "Third sentence.",
    }
    
    b.RunParallel(func(pb *testing.PB) {
        i := 0
        for pb.Next() {
            text := texts[i%len(texts)]
            _, _ = engine.Synthesize(context.Background(), text)
            i++
        }
    })
}
```

## Testing Utilities

### Test Helpers
```go
// testutil/helpers.go
package testutil

func LoadTestData(t *testing.T, filename string) []byte {
    t.Helper()
    
    path := filepath.Join("testdata", filename)
    data, err := os.ReadFile(path)
    require.NoError(t, err)
    
    return data
}

func TempDir(t *testing.T) string {
    t.Helper()
    
    dir, err := os.MkdirTemp("", "glow-tts-test-*")
    require.NoError(t, err)
    
    t.Cleanup(func() {
        os.RemoveAll(dir)
    })
    
    return dir
}

func RequireEventually(t *testing.T, condition func() bool, timeout time.Duration, msg string) {
    t.Helper()
    
    deadline := time.Now().Add(timeout)
    for time.Now().Before(deadline) {
        if condition() {
            return
        }
        time.Sleep(10 * time.Millisecond)
    }
    
    t.Fatalf("Condition not met within %v: %s", timeout, msg)
}
```

### Golden Files
```go
func TestMarkdownRenderer(t *testing.T) {
    input := LoadTestData(t, "input.md")
    
    got := RenderMarkdown(input)
    
    golden := filepath.Join("testdata", "golden", "output.txt")
    if *update {
        // Update golden file
        err := os.WriteFile(golden, got, 0644)
        require.NoError(t, err)
    }
    
    expected, err := os.ReadFile(golden)
    require.NoError(t, err)
    
    assert.Equal(t, string(expected), string(got))
}
```

## Testing Goroutines

### Testing Concurrent Code
```go
func TestQueueConcurrency(t *testing.T) {
    queue := NewQueue(10)
    
    var wg sync.WaitGroup
    errors := make(chan error, 100)
    
    // Producer goroutines
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 10; j++ {
                if err := queue.Enqueue(fmt.Sprintf("item-%d-%d", id, j)); err != nil {
                    errors <- err
                }
            }
        }(i)
    }
    
    // Consumer goroutines
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 20; j++ {
                _, _ = queue.Dequeue()
            }
        }()
    }
    
    // Wait for completion
    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
        // Success
    case <-time.After(5 * time.Second):
        t.Fatal("Test timed out")
    case err := <-errors:
        t.Fatalf("Unexpected error: %v", err)
    }
}
```

### Race Detection
```go
// Run tests with race detector
// go test -race ./...

func TestControllerRaceConditions(t *testing.T) {
    controller := NewController()
    
    // Start multiple goroutines that might race
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            controller.ProcessText("test")
        }()
    }
    
    wg.Add(1)
    go func() {
        defer wg.Done()
        controller.Stop()
    }()
    
    wg.Wait()
}
```

## Test Organization

### File Structure
```
glow-tts/
├── internal/
│   ├── tts/
│   │   ├── engine.go
│   │   ├── engine_test.go        # Unit tests
│   │   ├── engine_integration_test.go  # Integration tests
│   │   └── testdata/              # Test fixtures
│   │       ├── sample.txt
│   │       └── golden/
│   └── audio/
│       ├── player.go
│       ├── player_test.go
│       └── mock_player.go         # Mock for testing
└── test/
    ├── e2e/                       # End-to-end tests
    └── benchmark/                 # Performance tests
```

### Test Tags
```go
// +build integration
// Integration tests that require external resources

// +build !windows
// Tests that don't work on Windows

// +build slow
// Long-running tests
```

## CI/CD Integration

### Test Commands
```bash
# Unit tests only
go test ./...

# With coverage
go test -cover ./...
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# Integration tests
go test -tags=integration ./...

# Race detection
go test -race ./...

# Benchmarks
go test -bench=. ./...
go test -bench=. -benchmem ./...

# Specific test
go test -run TestSentenceParser ./internal/tts
```

### GitHub Actions
```yaml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Run tests
        run: |
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out
      
      - name: Run integration tests
        run: go test -v -tags=integration ./...
      
      - name: Run benchmarks
        run: go test -bench=. -benchmem ./...
```

---

*Comprehensive testing ensures reliability and maintainability of your TTS features.*
{
  "currentTag": "master",
  "tags": {
    "master": {
      "metadata": {
        "created": "2025-01-13T00:00:00Z",
        "description": "Main development tasks for Glow-TTS implementation"
      },
      "tasks": [
        {
          "id": "1",
          "title": "Implement Core Infrastructure Foundation",
          "description": "Establish the fundamental subprocess management patterns and audio memory handling to prevent critical race conditions",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "details": "This task creates the foundation layer that all other components will build upon. Must implement stdin race prevention using strings.NewReader pattern, establish proper audio memory management for OTO library, and ensure Bubble Tea command pattern compliance for all async operations.",
          "testStrategy": "Unit tests for subprocess creation patterns, memory leak tests for audio data lifecycle, integration tests with Bubble Tea UI to verify command pattern adherence",
          "subtasks": []
        },
        {
          "id": "2",
          "title": "Create TTS Controller and State Management",
          "description": "Build the main TTS Controller that orchestrates the entire text-to-speech pipeline",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "1"
          ],
          "details": "Implement the Controller struct that manages TTSEngine, AudioQueue, AudioPlayer, SentenceParser, CacheManager, and SpeedController components. This controller will coordinate all TTS operations and maintain state throughout the application lifecycle.",
          "testStrategy": "Unit tests for state transitions, integration tests for component coordination, mock engine tests to verify controller behavior",
          "subtasks": []
        },
        {
          "id": "3",
          "title": "Implement TTSEngine Interface and Basic Piper Engine",
          "description": "Create the engine abstraction layer and implement basic Piper TTS functionality",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "1",
            "2"
          ],
          "details": "Define the TTSEngine interface that will allow multiple TTS backends. Implement the Piper engine with subprocess spawning, ONNX model loading, and basic synthesis capabilities. Include proper timeout protection and error handling.",
          "testStrategy": "Unit tests for engine interface compliance, integration tests with actual Piper binary, performance tests for synthesis timing",
          "subtasks": []
        },
        {
          "id": "4",
          "title": "Build Sentence Parser for Markdown",
          "description": "Create the markdown-to-sentence parser that extracts speakable text while preserving structure",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "2"
          ],
          "details": "Implement SentenceParser that processes markdown documents and extracts sentences suitable for TTS synthesis. Must handle various markdown elements like headers, code blocks, links, and formatting while producing clean text for audio generation.",
          "testStrategy": "Unit tests with various markdown formats, edge case testing for complex markdown structures, validation of sentence boundary detection",
          "subtasks": []
        },
        {
          "id": "5",
          "title": "Implement Audio Playback with OTO",
          "description": "Create cross-platform audio playback system with proper memory management",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "1",
            "2"
          ],
          "details": "Build AudioPlayer using OTO v3 library with proper data lifecycle management to prevent memory corruption. Implement play, pause, stop controls and ensure audio data references remain alive during playback.",
          "testStrategy": "Memory leak tests, cross-platform playback tests, stress tests with rapid play/pause cycles",
          "subtasks": []
        },
        {
          "id": "6",
          "title": "Add CLI Flag Parsing and Engine Selection",
          "description": "Implement command-line interface for TTS activation and engine selection",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            "3"
          ],
          "details": "Add --tts flag with engine selection (piper/gtts), implement validation logic for dependencies, and provide clear error messages when requirements are not met. Force TUI mode when TTS is activated.",
          "testStrategy": "CLI argument parsing tests, validation tests for missing dependencies, integration tests with main Glow application",
          "subtasks": []
        },
        {
          "id": "7",
          "title": "Build Two-Level Cache System",
          "description": "Implement memory and disk caching layers for audio data",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "2",
            "5"
          ],
          "details": "Create CacheManager with L1 memory cache (100MB limit) and L2 disk cache (1GB limit). Implement SHA256-based cache key generation including text, voice, and speed parameters. Add automatic cleanup based on size, age, and session lifecycle.",
          "testStrategy": "Cache hit/miss ratio tests, memory usage monitoring, disk space cleanup validation, concurrent access tests",
          "subtasks": []
        },
        {
          "id": "8",
          "title": "Implement Audio Queue and Preprocessing",
          "description": "Create queue management system with lookahead buffer for seamless playback",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            "3",
            "4",
            "7"
          ],
          "details": "Build AudioQueue that maintains 2-3 sentence lookahead buffer, handles background preprocessing, and ensures smooth transitions between sentences. Integrate with caching system for optimal performance.",
          "testStrategy": "Buffer management tests, preprocessing timing tests, transition smoothness validation",
          "subtasks": []
        },
        {
          "id": "9",
          "title": "Complete Google TTS Engine Implementation",
          "description": "Add Google TTS engine support with gTTS CLI and ffmpeg pipeline",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            "3"
          ],
          "details": "Implement Google TTS engine using gTTS CLI for synthesis, MP3 to PCM conversion via ffmpeg, and speed control through atempo filter. Include dependency validation and error handling for network failures.",
          "testStrategy": "Network failure handling tests, audio format conversion validation, speed control accuracy tests",
          "subtasks": []
        },
        {
          "id": "10",
          "title": "Integrate TTS Controls into Bubble Tea UI",
          "description": "Add TTS control interface to existing Glow UI framework",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "2",
            "5",
            "6"
          ],
          "details": "Integrate TTS controls into Bubble Tea UI with keyboard shortcuts (space for play/pause, arrows for navigation, +/- for speed). Implement proper command pattern for all async operations and add status display showing engine, speed, and position.",
          "testStrategy": "UI interaction tests, keyboard shortcut validation, status display accuracy tests",
          "subtasks": []
        },
        {
          "id": "11",
          "title": "Implement Speed Control System",
          "description": "Add comprehensive speed control with engine-specific parameter mapping",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            "3",
            "9"
          ],
          "details": "Build SpeedController supporting 0.5x to 2.0x speeds in discrete steps. Map to Piper's length-scale parameter and Google TTS's ffmpeg atempo filter. Update cache keys to include speed parameter.",
          "testStrategy": "Speed accuracy tests for each engine, cache key uniqueness validation, user control response tests",
          "subtasks": []
        },
        {
          "id": "12",
          "title": "Add Comprehensive Error Handling",
          "description": "Implement production-grade error handling and recovery mechanisms",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            "3",
            "9",
            "10"
          ],
          "details": "Add 5-second timeout protection with SIGINT/SIGKILL sequence, implement graceful degradation for missing dependencies, create actionable error messages for users, and add recovery mechanisms for transient failures.",
          "testStrategy": "Timeout enforcement tests, error message clarity validation, recovery mechanism tests",
          "subtasks": []
        },
        {
          "id": "13",
          "title": "Create Configuration System",
          "description": "Build configuration file support with default settings management",
          "status": "pending",
          "priority": "low",
          "dependencies": [
            "2",
            "7",
            "11"
          ],
          "details": "Implement YAML-based configuration system for TTS settings including engine preferences, cache sizes, voice selection, and default speeds. Support both global and project-specific configurations.",
          "testStrategy": "Configuration parsing tests, default value validation, override precedence tests",
          "subtasks": []
        },
        {
          "id": "14",
          "title": "Add Logging and Debugging Capabilities",
          "description": "Implement comprehensive logging system for troubleshooting",
          "status": "pending",
          "priority": "low",
          "dependencies": [
            "12"
          ],
          "details": "Add structured logging with configurable levels, implement debug mode for verbose output, create performance metrics collection, and add cache hit rate monitoring.",
          "testStrategy": "Log output format tests, performance impact validation, metrics accuracy tests",
          "subtasks": []
        },
        {
          "id": "15",
          "title": "Write User Documentation",
          "description": "Create comprehensive user guides and troubleshooting documentation",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            "12",
            "13"
          ],
          "details": "Write installation guides for all dependencies, create troubleshooting guides for common issues, document keyboard shortcuts and controls, and provide configuration examples.",
          "testStrategy": "Documentation accuracy validation, example code testing, user feedback incorporation",
          "subtasks": []
        }
      ]
    }
  },
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Core TTS Controller and Infrastructure",
        "description": "Create the main TTS Controller struct and establish critical subprocess management patterns to prevent stdin race conditions",
        "details": "Create pkg/tts/controller.go with TTS Controller struct containing engine, queue, player, parser, cache, and speedCtrl fields. Implement subprocess management using cmd.Stdin = strings.NewReader(text) pattern before process start to prevent critical race conditions. Add basic state management and initialization logic. Create TTSEngine interface in pkg/tts/engine.go with Synthesize, SetSpeed, and Validate methods.",
        "testStrategy": "Unit tests for Controller initialization, subprocess pattern validation with mock processes, and TTSEngine interface compliance tests",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create base TTS Controller struct with core fields",
            "description": "Define the main Controller struct in pkg/tts/controller.go with all necessary fields for managing TTS operations",
            "dependencies": [],
            "details": "Create pkg/tts/controller.go and define the Controller struct with fields: engine (TTSEngine interface), queue (*AudioQueue), player (*AudioPlayer), parser (TextParser interface), cache (CacheManager interface), speedCtrl (SpeedController interface), state (sync.RWMutex protected state management), and context for lifecycle management. Add struct tags and documentation for each field. Include basic constructor function NewController() with field initialization.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Define TTSEngine interface with core synthesis methods",
            "description": "Create the TTSEngine interface in pkg/tts/engine.go defining the contract for all TTS engine implementations",
            "dependencies": [],
            "details": "Create pkg/tts/engine.go and define TTSEngine interface with methods: Synthesize(text string, speed float64) ([]byte, error) for text-to-speech conversion, SetSpeed(speed float64) error for speed adjustment validation, Validate() error for dependency checking, GetName() string for engine identification, and IsAvailable() bool for runtime availability checks. Add comprehensive documentation explaining the PCM output format requirements (16-bit mono 22050Hz) and error handling expectations.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement subprocess management with stdin race prevention",
            "description": "Create safe subprocess execution patterns in the controller to prevent stdin race conditions",
            "dependencies": [
              "1.1"
            ],
            "details": "In pkg/tts/controller.go, implement executeSubprocess(cmd *exec.Cmd, input string) ([]byte, error) method using the critical pattern: cmd.Stdin = strings.NewReader(input) before cmd.Start() to prevent race conditions. Add process lifecycle management with proper cleanup using defer statements. Implement timeout handling with context.WithTimeout. Create error wrapping for better debugging. Add logging for subprocess execution lifecycle events. Document the race condition prevention pattern prominently.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add state management and lifecycle methods to Controller",
            "description": "Implement controller initialization, state tracking, and graceful shutdown mechanisms",
            "dependencies": [
              "1.1",
              "1.2"
            ],
            "details": "Add Initialize() error method to validate and setup all components. Implement Start(ctx context.Context) error for beginning TTS operations with goroutine management. Add Stop() error for graceful shutdown with resource cleanup. Create state enum (Uninitialized, Ready, Running, Stopping, Stopped) with thread-safe transitions using sync.RWMutex. Implement GetState() State and setState(state State) methods. Add error aggregation for multi-component initialization failures. Include panic recovery in critical paths.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create comprehensive unit tests for controller and subprocess patterns",
            "description": "Write unit tests validating controller initialization, subprocess management, and race condition prevention",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "Create pkg/tts/controller_test.go with TestNewController for initialization validation. Implement TestSubprocessExecution with mock processes to verify stdin race prevention using concurrent goroutines attempting to write. Add TestControllerLifecycle covering all state transitions. Create TestEngineInterface compliance tests using mock implementations. Add benchmark tests for subprocess execution patterns. Include race detector tests with go test -race. Test error conditions including initialization failures and subprocess timeouts.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Audio Memory Management with OTO Integration",
        "description": "Build cross-platform audio playback system with proper memory lifecycle management to prevent audio corruption",
        "details": "Add github.com/ebitengine/oto/v3 to go.mod. Create pkg/tts/player.go with AudioStream struct containing data []byte, reader *bytes.Reader, and player oto.Player fields. Implement proper memory lifecycle management to keep audio data alive during playback. Add PCM audio format support (16-bit mono 22050Hz). Create playback controls (play, pause, stop) with proper resource cleanup.",
        "testStrategy": "Audio playback tests with different PCM formats, memory lifecycle tests to prevent corruption, and cross-platform compatibility validation",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add OTO v3 dependency and initialize audio context",
            "description": "Add github.com/ebitengine/oto/v3 to go.mod and create initialization logic for the OTO audio context with proper error handling",
            "dependencies": [],
            "details": "Run 'go get github.com/ebitengine/oto/v3' to add the dependency. Create an initialization function that sets up the OTO context with appropriate sample rate (22050Hz), channel count (1 for mono), and bit depth (16-bit). Include platform-specific initialization parameters and handle context creation errors gracefully. Validate that the audio context can be created on the target platform.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create AudioStream struct with memory management",
            "description": "Implement the AudioStream struct in pkg/tts/player.go with proper fields for data persistence and memory lifecycle management",
            "dependencies": [
              "2.1"
            ],
            "details": "Define AudioStream struct with fields: data []byte (to hold PCM audio data), reader *bytes.Reader (for streaming), player oto.Player (for playback control), and additional fields for state management (isPlaying bool, isPaused bool, mutex sync.RWMutex). Implement NewAudioStream constructor that properly initializes all fields and ensures data remains in memory during the stream's lifetime. Add methods to safely access and modify the audio data while preventing garbage collection during playback.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement PCM audio format handling",
            "description": "Add PCM format validation and conversion utilities for 16-bit mono 22050Hz audio data",
            "dependencies": [
              "2.2"
            ],
            "details": "Create ValidatePCMFormat function to verify incoming audio data matches expected format (16-bit signed integer, mono channel, 22050Hz sample rate). Implement conversion utilities if needed to normalize audio data to the expected format. Add methods to calculate buffer sizes, duration, and byte positions based on PCM parameters. Include helper functions for reading/writing PCM headers if necessary for debugging or file output.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build playback controls with state management",
            "description": "Implement Play, Pause, Stop, and Resume methods with proper state transitions and thread safety",
            "dependencies": [
              "2.3"
            ],
            "details": "Implement Play() method that creates an OTO player instance, starts audio streaming from the bytes.Reader, and updates state flags. Add Pause() to temporarily halt playback while maintaining position. Implement Resume() to continue from paused position. Create Stop() to terminate playback and reset position. Use mutex locks to ensure thread-safe state transitions. Add GetState() method to query current playback status. Include position tracking for seek functionality foundation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add resource cleanup and memory lifecycle management",
            "description": "Implement proper cleanup mechanisms to prevent memory leaks and audio corruption during stream lifecycle",
            "dependencies": [
              "2.4"
            ],
            "details": "Implement Close() method that properly releases OTO player resources, clears audio buffers, and signals garbage collection readiness. Add finalizer using runtime.SetFinalizer to ensure cleanup even if Close() isn't explicitly called. Implement reference counting or pinning mechanism to prevent premature garbage collection of audio data during playback. Create cleanup validation to ensure all resources are properly released. Add panic recovery in cleanup paths to prevent resource leaks on errors.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Write cross-platform tests for audio playback",
            "description": "Create comprehensive test suite validating audio playback, memory management, and cross-platform compatibility",
            "dependencies": [
              "2.5"
            ],
            "details": "Write unit tests for AudioStream creation and initialization across different platforms (Linux, macOS, Windows). Create integration tests that play short PCM samples and verify proper playback without corruption. Add memory leak tests using runtime.MemStats to ensure proper cleanup. Implement stress tests with rapid play/stop cycles to validate resource management. Create benchmark tests for performance validation. Add platform-specific test cases for audio context initialization. Include tests for concurrent playback scenarios and edge cases like zero-length audio or invalid PCM data.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate TTS Controls with Bubble Tea UI Framework",
        "description": "Add TTS command patterns to existing Bubble Tea UI and implement CLI flag detection for explicit TTS activation",
        "details": "Add --tts flag to main.go CLI arguments with engine selection (piper|gtts). Modify ui/ui.go to include TTS state in model struct. Implement Bubble Tea command pattern for all TTS async operations - no direct goroutines. Add TTS status display showing engine, speed, sentence position. Create keyboard shortcuts: Space (play/pause), arrows (navigation), +/- (speed control). Ensure TUI mode is mandatory when --tts flag is used.",
        "testStrategy": "UI integration tests for TTS controls, command pattern validation, keyboard shortcut functionality, and CLI flag parsing tests",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add --tts CLI flag parsing with engine selection",
            "description": "Implement command-line flag parsing in main.go to detect --tts flag with engine selection (piper|gtts)",
            "dependencies": [],
            "details": "Modify main.go to add --tts flag using existing CLI parsing structure. Accept engine parameter as --tts=piper or --tts=gtts. Default to piper if no engine specified. Store selected engine in config struct. Ensure TUI mode is automatically enabled when --tts flag is present. Pass TTS configuration to ui.NewProgram() initialization.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Extend Bubble Tea model struct with TTS state",
            "description": "Modify ui/ui.go model struct to include comprehensive TTS state management fields",
            "dependencies": [],
            "details": "Add TTSController field to model struct in ui/ui.go. Include TTS state fields: isPlaying bool, isPaused bool, currentSentenceIndex int, currentSpeed float64, ttsEngine string. Add fields for audio queue management and sentence navigation tracking. Ensure proper initialization of TTS state in NewProgram() when --tts flag is detected.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Bubble Tea commands for async TTS operations",
            "description": "Create command pattern implementation for all TTS operations following Bubble Tea async patterns",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Create ttsPlayCmd, ttsPauseCmd, ttsNextCmd, ttsPrevCmd commands in ui/ui.go. Implement ttsSpeedChangeCmd for speed adjustments. Use tea.Cmd return type for all async operations - no direct goroutines. Create command factories that return tea.Cmd functions wrapping TTS controller calls. Ensure proper error handling and state updates through command results.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add keyboard shortcuts for TTS control",
            "description": "Implement keyboard event handlers for Space, arrow keys, and +/- speed controls",
            "dependencies": [
              "3.3"
            ],
            "details": "In Update() method, add case handlers for: Space key to toggle play/pause, Left/Right arrows for previous/next sentence navigation, Up/Down arrows for paragraph navigation, +/- keys for speed increment/decrement. Return appropriate TTS commands from key handlers. Ensure shortcuts only active when TTS is enabled. Add visual feedback for key actions in status display.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create TTS status display component",
            "description": "Build UI component showing TTS engine, playback status, speed, and sentence position",
            "dependencies": [
              "3.2",
              "3.4"
            ],
            "details": "Create renderTTSStatus() method in ui/ui.go View() function. Display current engine (Piper/Google TTS), playback state (Playing/Paused/Stopped), current speed (0.5x-2.0x), sentence position (e.g., '3/15 sentences'). Use lipgloss for styling consistent with existing UI. Position status bar at bottom or integrate with existing status display. Update display reactively based on model state changes.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Enforce TUI mode and integrate TTS initialization",
            "description": "Ensure TUI mode is mandatory with --tts flag and properly initialize TTS controller",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "In main.go, force TUI mode when --tts flag is detected regardless of other flags. Initialize TTS controller in ui.NewProgram() when TTS is enabled. Connect TTS controller to model struct. Implement Init() command to start TTS preprocessing if auto-play is enabled. Add graceful shutdown handling for TTS resources in tea.Quit command. Validate TTS engine availability before UI initialization.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Sentence Parser for Markdown Text Extraction",
        "description": "Build intelligent markdown parser that extracts speakable sentences while preserving document structure",
        "details": "Create pkg/tts/parser.go with SentenceParser struct. Implement markdown parsing that extracts clean text for synthesis while maintaining original formatting. Create Sentence struct with Text (clean), Position (document index), and Original (markdown) fields. Handle special markdown elements (code blocks, links, headers) appropriately for speech. Implement sentence boundary detection with proper punctuation handling.",
        "testStrategy": "Parser tests with various markdown formats, sentence extraction accuracy validation, and edge case handling for complex markdown structures",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SentenceParser struct and Sentence model",
            "description": "Define the core data structures for sentence parsing including SentenceParser struct in pkg/tts/parser.go and Sentence struct with Text, Position, and Original fields",
            "dependencies": [],
            "details": "Create pkg/tts/parser.go file. Define Sentence struct with fields: Text (string for clean speakable text), Position (int for document index), Original (string for original markdown). Define SentenceParser struct with necessary fields for markdown processing state. Add constructor function NewSentenceParser() and basic initialization logic.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate glamour markdown parsing",
            "description": "Implement markdown element extraction leveraging the existing glamour integration patterns from the codebase",
            "dependencies": [
              "4.1"
            ],
            "details": "Study existing glamour usage in the codebase for markdown rendering. Create Parse(markdown string) method on SentenceParser that uses glamour to extract text content. Handle markdown AST traversal to extract plain text while preserving structure information. Map glamour elements to internal representation for further processing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement sentence boundary detection logic",
            "description": "Add intelligent sentence boundary detection with proper punctuation rules and edge case handling",
            "dependencies": [
              "4.2"
            ],
            "details": "Implement detectSentences(text string) []Sentence method with punctuation-based splitting (periods, exclamation marks, question marks). Handle abbreviations and decimal numbers that contain periods. Implement lookahead/lookbehind logic for proper sentence boundaries. Handle ellipsis and other special punctuation patterns. Preserve original markdown positions during sentence extraction.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle special markdown elements for speech",
            "description": "Process code blocks, links, headers, and other markdown elements appropriately for TTS synthesis",
            "dependencies": [
              "4.3"
            ],
            "details": "Implement handleCodeBlock() to either skip or announce code blocks based on configuration. Convert links to speakable format (e.g., 'link to [text]' or just the link text). Transform headers into pausable boundaries with appropriate emphasis. Handle lists and blockquotes with proper speech formatting. Process inline code, bold, and italic elements for natural speech flow.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Write comprehensive parser tests",
            "description": "Create thorough test suite covering various markdown formats and edge cases for the sentence parser",
            "dependencies": [
              "4.4"
            ],
            "details": "Create pkg/tts/parser_test.go with test cases for basic sentence extraction. Add tests for complex markdown with nested elements (links in lists, code in blockquotes). Test sentence boundary detection with abbreviations, numbers, and special punctuation. Verify correct handling of empty lines and whitespace. Test performance with large markdown documents. Include edge cases like malformed markdown and unicode content.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Basic Piper TTS Engine",
        "description": "Create the offline Piper TTS engine implementation with dependency validation and basic synthesis capability",
        "details": "Create pkg/tts/engines/piper.go implementing TTSEngine interface. Add dependency detection for piper binary in PATH and ONNX voice models. Implement synthesis using fresh process per call with proper subprocess management. Add --length-scale parameter for speed control (0.5x-2.0x). Include model validation and voice selection. Handle PCM audio output conversion and error handling with clear user guidance.",
        "testStrategy": "Piper binary detection tests, synthesis quality validation, speed control verification, and comprehensive error handling tests",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Piper engine structure and TTSEngine interface implementation",
            "description": "Set up the basic Piper engine struct in pkg/tts/engines/piper.go with all required fields and implement the TTSEngine interface methods (Synthesize, SetSpeed, Validate)",
            "dependencies": [],
            "details": "Create piper.go file with PiperEngine struct containing fields for binary path, model path, speed setting, and process management. Implement TTSEngine interface with method stubs. Add constants for default speed range (0.5-2.0) and audio format parameters (16-bit mono 22050Hz PCM).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Piper binary and ONNX model detection",
            "description": "Add dependency validation logic to detect piper binary in PATH and locate ONNX voice models in standard locations",
            "dependencies": [
              "5.1"
            ],
            "details": "Implement Validate() method to check for piper binary using exec.LookPath. Search for ONNX models in common locations (~/.local/share/piper-voices/, /usr/share/piper-voices/). Validate model files exist and are accessible. Return clear error messages with installation instructions if dependencies are missing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement subprocess management for synthesis",
            "description": "Create the core synthesis logic using fresh process per call with proper stdin handling to prevent race conditions",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Implement Synthesize() method using exec.Command for piper binary. Apply the cmd.Stdin = strings.NewReader(text) pattern before process start. Add --output-raw flag for PCM output, --model flag for ONNX model path. Implement proper process lifecycle management with context support for cancellation. Handle process exit codes and stderr for error reporting.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add speed control with --length-scale parameter",
            "description": "Implement SetSpeed method and integrate --length-scale parameter into synthesis command",
            "dependencies": [
              "5.3"
            ],
            "details": "Implement SetSpeed() method to store speed setting (0.5-2.0 range). Add --length-scale parameter to piper command with inverse calculation (2.0 speed = 0.5 length-scale). Validate speed values and provide clear error messages for out-of-range values. Update synthesis command builder to include length-scale when speed != 1.0.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Handle PCM audio output conversion and buffering",
            "description": "Implement PCM audio data collection from piper stdout with proper buffering and format validation",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "details": "Read PCM data from cmd.StdoutPipe() into byte buffer. Validate PCM format (16-bit mono 22050Hz). Handle partial reads and implement proper buffering strategy. Convert raw PCM bytes to []byte for return value. Add audio data size validation and handle edge cases like empty output.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create comprehensive error handling with user guidance",
            "description": "Implement detailed error handling throughout the engine with actionable user messages",
            "dependencies": [
              "5.2",
              "5.3",
              "5.5"
            ],
            "details": "Create custom error types for different failure scenarios (dependency missing, model not found, synthesis failed). Add helpful error messages with installation/fix instructions. Implement error wrapping for context preservation. Add logging for debugging subprocess issues. Handle timeout scenarios and provide recovery suggestions.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Build Two-Level Caching System",
        "description": "Implement memory and disk caching architecture for optimal TTS performance with automatic cleanup",
        "details": "Create pkg/tts/cache.go with CacheManager struct. Implement L1 memory cache (100MB limit, <1ms access) and L2 disk cache (1GB limit, 7-day TTL). Use SHA256(text|voice|speed) for cache keys. Add automatic cleanup based on size, age, and session lifecycle. Implement cache hit rate monitoring. Create AudioData struct with Audio []byte, Text string, Speed float64, and CacheKey string fields. Use platform-specific cache directories with restricted permissions.",
        "testStrategy": "Cache performance benchmarks, hit rate validation (target >80%), cleanup mechanism tests, and cross-session persistence verification",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design CacheManager Architecture and Interfaces",
            "description": "Create the core CacheManager struct and define interfaces for L1 and L2 cache layers with common operations",
            "dependencies": [],
            "details": "Create pkg/tts/cache.go with CacheManager struct containing L1Cache and L2Cache interfaces. Define Cache interface with Get(key string), Put(key string, data *AudioData), Delete(key string), Size() int64, and Clear() methods. Create AudioData struct with Audio []byte, Text string, Speed float64, and CacheKey string fields. Design configuration struct with L1SizeLimit (100MB), L2SizeLimit (1GB), and TTL (7 days) parameters.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement L1 Memory Cache with LRU Eviction",
            "description": "Build the in-memory cache layer with size-based LRU eviction and sub-millisecond access times",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement MemoryCache struct satisfying L1Cache interface. Use sync.Map or custom concurrent map for <1ms access. Implement LRU eviction using container/list for tracking access order. Add size tracking with atomic operations for thread safety. Implement automatic eviction when approaching 100MB limit. Include metrics for hit/miss rates and access times using sync/atomic counters.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build L2 Disk Cache with Platform-Specific Storage",
            "description": "Create the persistent disk cache layer with platform-aware directory management and file permissions",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement DiskCache struct satisfying L2Cache interface. Use os.UserCacheDir() for platform-specific cache directories (XDG_CACHE_HOME on Linux, ~/Library/Caches on macOS, %LOCALAPPDATA% on Windows). Set restrictive permissions (0700) on cache directory. Implement file-based storage with metadata files containing timestamp, size, and access count. Add file locking for concurrent access safety. Include compression for audio data to optimize disk usage.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement SHA256-Based Cache Key Generation",
            "description": "Create deterministic cache key generation using SHA256 hashing of text, voice, and speed parameters",
            "dependencies": [
              "6.1"
            ],
            "details": "Create GenerateCacheKey(text, voice, speed string) function using crypto/sha256. Normalize input parameters before hashing (trim whitespace, lowercase voice names, format speed to 2 decimal places). Generate hex-encoded 64-character keys. Add key validation and collision detection. Implement key prefix for versioning (v1_<hash>). Include unit tests for key determinism and parameter sensitivity.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build Automatic Cleanup and Lifecycle Management",
            "description": "Implement multi-criteria cleanup system based on size limits, age, and session lifecycle",
            "dependencies": [
              "6.2",
              "6.3"
            ],
            "details": "Create CleanupManager with goroutine-based background cleanup. Implement size-based cleanup triggering at 90% capacity for both L1 and L2. Add age-based cleanup removing entries older than 7 days for L2, 1 hour for L1. Implement session lifecycle hooks for cleanup on application exit. Use heap data structure for efficient LRU/LFU tracking. Add configurable cleanup intervals and thresholds. Include graceful shutdown with cleanup completion.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Cache Metrics and Hit Rate Monitoring",
            "description": "Implement comprehensive metrics collection for cache performance monitoring and optimization",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Create CacheMetrics struct with hit/miss counters, access times, and size tracking. Implement rolling window statistics for hit rates (1min, 5min, 15min averages). Add per-cache-level metrics (L1 vs L2 hit rates). Include cache promotion/demotion tracking between levels. Export metrics in Prometheus-compatible format. Add debug logging for cache operations with configurable verbosity. Target >80% combined hit rate.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Write Performance Benchmarks and Persistence Tests",
            "description": "Create comprehensive test suite validating performance requirements and cross-session persistence",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Write benchmark tests validating <1ms L1 access using testing.B. Create load tests simulating concurrent access patterns. Test LRU eviction correctness under memory pressure. Validate disk persistence across process restarts. Test cleanup mechanisms with time manipulation. Benchmark cache key generation performance. Validate platform-specific directory creation and permissions. Test cache coherency between L1 and L2 layers.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Audio Queue with Preprocessing Pipeline",
        "description": "Create background audio processing with 2-3 sentence lookahead buffer for seamless playback transitions",
        "details": "Create pkg/tts/queue.go with AudioQueue struct managing preprocessing and playback order. Implement 2-3 sentence lookahead buffer with background synthesis. Add queue management for previous/next navigation. Implement preprocessing pipeline that eliminates gaps between sentences. Create buffer management with proper memory handling and garbage collection considerations. Add queue state tracking and debugging capabilities.",
        "testStrategy": "Queue management tests, lookahead buffer validation, seamless transitions verification, and memory usage monitoring",
        "priority": "medium",
        "dependencies": [
          2,
          6
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Design AudioQueue Struct and Core Architecture",
            "description": "Create AudioQueue struct with fields for buffer management, state tracking, and concurrent processing control",
            "dependencies": [],
            "details": "Define AudioQueue struct in pkg/tts/queue.go with fields: buffer []AudioSegment, bufferSize int, currentIndex int, processingQueue chan TextSegment, synthesisWorkers int, mu sync.RWMutex, state QueueState, and ctx context.Context. Create AudioSegment type containing audio data, text reference, and metadata. Define QueueState enum (idle, processing, playing). Establish interfaces for queue operations and callback mechanisms.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Lookahead Buffer with Background Synthesis",
            "description": "Build 2-3 sentence lookahead buffer system with background synthesis workers for continuous audio preparation",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement NewAudioQueue(bufferSize int) constructor with default 3-sentence lookahead. Create background worker pool using goroutines for concurrent synthesis. Implement AddToQueue(text string) method that triggers background processing. Build buffer management logic to maintain 2-3 sentences ahead of current playback position. Add automatic buffer refill when dropping below threshold. Implement proper synchronization between synthesis workers and buffer updates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Queue Navigation and Control Methods",
            "description": "Implement previous/next navigation with proper buffer management and state transitions",
            "dependencies": [
              "7.2"
            ],
            "details": "Create Next() and Previous() methods for queue navigation with bounds checking. Implement Skip(n int) for jumping to specific positions. Add GetCurrent() and GetQueuedItems() for state inspection. Build position tracking with currentPosition and totalItems counters. Implement queue reordering logic for dynamic priority changes. Add Clear() and Reset() methods for queue management.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Preprocessing Pipeline for Seamless Transitions",
            "description": "Implement audio preprocessing pipeline that eliminates gaps between sentences for continuous playback",
            "dependencies": [
              "7.2"
            ],
            "details": "Build PreprocessAudio(raw []byte) method to normalize audio segments. Implement silence trimming at segment boundaries using audio amplitude detection. Add crossfade blending between consecutive segments (50-100ms overlap). Create audio level normalization to maintain consistent volume. Implement format conversion pipeline ensuring consistent PCM parameters. Add configurable transition duration settings.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Memory Management and Garbage Collection",
            "description": "Build efficient memory management system with proper cleanup and garbage collection optimization",
            "dependencies": [
              "7.3",
              "7.4"
            ],
            "details": "Implement buffer eviction policy using LRU cache for processed segments. Create ReleaseSegment(index int) for manual memory release. Add automatic cleanup of played segments after configurable retention period. Implement memory pooling for AudioSegment allocations to reduce GC pressure. Add MaxMemoryUsage limit with automatic buffer size adjustment. Create background cleanup goroutine monitoring memory usage and triggering collection when threshold exceeded.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Queue State Tracking and Debugging Capabilities",
            "description": "Implement comprehensive state tracking, metrics collection, and debugging tools for queue operations",
            "dependencies": [
              "7.5"
            ],
            "details": "Create GetQueueStats() returning metrics: queue depth, buffer utilization, synthesis rate, memory usage. Implement state change notifications using callback pattern or channels. Add detailed logging with configurable levels (debug, info, warn, error). Create DumpQueueState() for debugging snapshots. Implement performance metrics tracking (synthesis time, buffer hits/misses). Add visual queue state representation for debugging output.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Create Speed Control System",
        "description": "Build comprehensive speed control with engine-specific parameter mapping and discrete speed steps",
        "details": "Create pkg/tts/speed.go with SpeedController struct. Implement discrete speed steps from 0.5x to 2.0x (0.5, 0.75, 1.0, 1.25, 1.5, 2.0). Add engine-specific parameter mapping (Piper length-scale vs Google TTS ffmpeg atempo). Speed changes affect new synthesis only, maintaining current playback. Update cache keys to include speed parameter. Add keyboard controls (+/-) for speed adjustment with visual feedback in UI.",
        "testStrategy": "Speed control accuracy tests, engine-specific parameter validation, cache key generation with speed, and UI feedback verification",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SpeedController struct with discrete speed steps",
            "description": "Implement the core SpeedController struct in pkg/tts/speed.go with predefined discrete speed values and state management",
            "dependencies": [],
            "details": "Create pkg/tts/speed.go with SpeedController struct containing currentSpeed float64, availableSpeeds []float64 (0.5, 0.75, 1.0, 1.25, 1.5, 2.0), and mutex for thread-safe operations. Implement NewSpeedController() constructor with default speed 1.0. Add GetSpeed(), SetSpeed(speed float64), NextSpeed(), and PreviousSpeed() methods. Validate speed values against available discrete steps. Include IsValidSpeed(speed float64) helper method.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement engine-specific parameter mapping",
            "description": "Create parameter mapping logic that translates generic speed values to engine-specific parameters for Piper and Google TTS",
            "dependencies": [
              "8.1"
            ],
            "details": "Add GetEngineParameter(engineType string, speed float64) method to SpeedController. For Piper engine, map speed to --length-scale parameter (inverse relationship: speed 2.0 = length-scale 0.5). For Google TTS, prepare ffmpeg atempo parameter mapping (direct relationship: speed 2.0 = atempo 2.0). Create EngineParameterMap type for storing engine-specific configurations. Include validation for parameter ranges specific to each engine.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Update cache key generation to include speed parameter",
            "description": "Modify cache key generation logic to incorporate speed value, ensuring different speeds generate unique cache entries",
            "dependencies": [
              "8.1"
            ],
            "details": "Update cache key generation to use SHA256(text|voice|speed) format. Modify GenerateCacheKey() function to accept speed parameter. Ensure speed value is normalized to string format with consistent precision (e.g., '1.50' not '1.5'). Update all cache lookups and stores to use new key format. Add migration logic to handle existing cache entries without speed parameter.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate keyboard controls with UI feedback",
            "description": "Add keyboard handlers for speed adjustment and visual feedback display in the TUI",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3"
            ],
            "details": "Implement keyboard handlers for '+' (increase speed) and '-' (decrease speed) keys in the TUI event loop. Add visual speed indicator to UI showing current speed value (e.g., 'Speed: 1.25x'). Create UpdateSpeedDisplay() method for real-time UI updates. Ensure speed changes only affect new synthesis, not current playback. Add toast notification or status message when speed changes. Include bounds checking to prevent invalid speed selections.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Google TTS Engine with Pipeline",
        "description": "Create online Google TTS engine using gTTS CLI with ffmpeg audio processing pipeline",
        "details": "Create pkg/tts/engines/gtts.go implementing TTSEngine interface. Add dependency detection for gtts-cli (pip install gTTS) and ffmpeg. Implement synthesis pipeline: gTTS CLI  MP3  ffmpeg atempo  PCM conversion. Use ffmpeg atempo filter for speed control instead of Piper's length-scale. Add internet connectivity validation. Implement proper error handling with actionable user guidance. No API key required - uses free gTTS service.",
        "testStrategy": "Dependency detection tests, synthesis pipeline validation, speed control via ffmpeg, connectivity handling, and error recovery tests",
        "priority": "medium",
        "dependencies": [
          1,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GTTSEngine struct implementing TTSEngine interface",
            "description": "Implement the core Google TTS engine structure with TTSEngine interface methods in pkg/tts/engines/gtts.go",
            "dependencies": [],
            "details": "Create pkg/tts/engines/gtts.go file. Define GTTSEngine struct with fields for configuration (language, slow mode flag). Implement TTSEngine interface methods: Synthesize(text string) ([]byte, error), SetSpeed(speed float32) error, and Validate() error. Add internal fields for tracking ffmpeg speed setting and temporary file management. Follow the same patterns established in piper.go for consistency.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement dependency detection for gtts-cli and ffmpeg",
            "description": "Add robust dependency checking for both gtts-cli Python package and ffmpeg binary with actionable error messages",
            "dependencies": [
              "9.1"
            ],
            "details": "Implement checkGTTSCLI() function to verify gtts-cli is installed via pip. Use exec.LookPath() to check for gtts-cli in PATH. Implement checkFFmpeg() function to verify ffmpeg binary availability. Add version checking for compatibility. Return detailed error messages with installation instructions: 'gtts-cli not found. Install with: pip install gTTS' and 'ffmpeg not found. Install via your package manager'. Call both checks in Validate() method.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build gTTS to MP3 synthesis pipeline",
            "description": "Implement the first stage of the pipeline using gTTS CLI to generate MP3 output with internet connectivity validation",
            "dependencies": [
              "9.1",
              "9.2"
            ],
            "details": "Create synthesizeToMP3() method that constructs gtts-cli command with proper arguments: gtts-cli --text 'text' --output temp.mp3 --lang en. Add internet connectivity check before synthesis attempt using net.Dial to google.com:443. Handle temporary file creation with ioutil.TempFile for MP3 output. Implement proper error handling for network failures, returning user-friendly messages like 'Internet connection required for Google TTS'. Use cmd.Stdin = strings.NewReader(text) pattern to avoid stdin race conditions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement ffmpeg audio processing pipeline with atempo filter",
            "description": "Create the MP3 to PCM conversion pipeline with ffmpeg atempo filter for speed control",
            "dependencies": [
              "9.3"
            ],
            "details": "Implement convertMP3ToPCM() method that takes MP3 file path and speed factor. Construct ffmpeg command: ffmpeg -i input.mp3 -af atempo=speed -f s16le -ar 22050 -ac 1 pipe:1. Map speed values (0.5-2.0) to atempo filter values. Handle ffmpeg stdout to capture PCM data into byte slice. Implement proper subprocess management with context cancellation. Add error handling for invalid speed values and ffmpeg failures. Clean up temporary MP3 file after conversion.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate complete synthesis pipeline with error recovery",
            "description": "Wire together the complete gTTS  MP3  ffmpeg  PCM pipeline in the Synthesize method",
            "dependencies": [
              "9.3",
              "9.4"
            ],
            "details": "Implement Synthesize() method orchestrating the full pipeline: call synthesizeToMP3(), then convertMP3ToPCM() with current speed setting. Add retry logic for transient network failures (max 2 retries with exponential backoff). Implement proper cleanup of all temporary files in defer blocks. Add detailed logging at each pipeline stage for debugging. Return PCM audio data in correct format (16-bit mono 22050Hz). Ensure all error messages guide users to solutions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add comprehensive error handling and user guidance",
            "description": "Implement detailed error handling with actionable messages for all failure scenarios",
            "dependencies": [
              "9.5"
            ],
            "details": "Create custom error types for different failure modes: NetworkError, DependencyError, ProcessError. Implement fallback behavior for network failures (suggest offline engines). Add detailed error messages with resolution steps for each error type. Create validateConnectivity() helper for pre-flight checks. Implement GetLastError() method for debugging. Add timeout handling for long-running synthesis operations (30s max). Include example usage documentation in comments.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Add Comprehensive Error Handling and Production Polish",
        "description": "Implement robust error handling, dependency validation, timeout protection, and user documentation",
        "details": "Add 5-second timeout protection with graceful SIGINT/SIGKILL sequence for all subprocess calls. Implement comprehensive dependency checking with clear setup guidance. Add engine availability detection with helpful error messages. Create configuration file support (.glow/config.yml) with TTS settings. Implement logging and debugging capabilities. Add user documentation for setup and troubleshooting. Create installation guides for Piper and Google TTS dependencies. Add graceful shutdown handling and resource cleanup.",
        "testStrategy": "Timeout protection validation, dependency error message clarity, configuration loading tests, and comprehensive integration testing across platforms",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement subprocess timeout protection system",
            "description": "Add 5-second timeout mechanism with graceful SIGINT/SIGKILL sequence for all TTS engine subprocess calls",
            "dependencies": [],
            "details": "Create pkg/tts/timeout.go with TimeoutExecutor struct. Implement RunWithTimeout(cmd *exec.Cmd, timeout time.Duration) that sends SIGINT after timeout, waits 500ms for graceful shutdown, then sends SIGKILL if needed. Integrate with both Piper and Google TTS engine subprocess calls. Add context cancellation support for proper cleanup. Include timeout configuration in engine structs with sensible defaults.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Build dependency validation and setup guidance system",
            "description": "Create comprehensive dependency checking with clear error messages and installation instructions",
            "dependencies": [],
            "details": "Create pkg/tts/dependencies.go with DependencyChecker interface. Implement CheckPiper() for piper binary and ONNX models, CheckGTTS() for gtts-cli and ffmpeg. Add CheckSystemDependencies() that validates all required tools on startup. Create helpful error messages with platform-specific installation commands (brew/apt/pip). Include version checking where applicable. Add --check-deps flag to validate without running.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create configuration file system with .glow/config.yml",
            "description": "Implement YAML configuration support for TTS settings using viper",
            "dependencies": [],
            "details": "Create pkg/config/config.go extending existing viper setup. Define config structure for TTS settings: default engine, cache limits, timeout values, voice preferences, speed defaults. Support ~/.config/glow/config.yml and ./.glow/config.yml with proper precedence. Add config validation and migration from old settings. Include example config generation with --generate-config flag. Integrate with existing glamour style configuration.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement logging and debugging capabilities",
            "description": "Add structured logging using charmbracelet/log with debug levels and TTS-specific logging",
            "dependencies": [
              "10.3"
            ],
            "details": "Extend existing charmbracelet/log usage for TTS operations. Add debug levels: ERROR, WARN, INFO, DEBUG, TRACE. Create TTS-specific loggers for cache hits/misses, engine selection, synthesis timing, subprocess execution. Add --debug and --trace flags for verbose output. Include performance metrics logging (synthesis time, cache efficiency). Write logs to ~/.glow/debug.log when debug enabled.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Write comprehensive user documentation",
            "description": "Create setup guides, troubleshooting docs, and installation instructions for all TTS dependencies",
            "dependencies": [
              "10.2"
            ],
            "details": "Create docs/TTS_SETUP.md with platform-specific Piper installation (models, voices). Add docs/TTS_TROUBLESHOOTING.md for common issues and solutions. Write Google TTS setup guide with pip installation steps. Document configuration file options and examples. Add keyboard shortcuts reference for TTS controls. Include performance tuning guide for cache settings. Create quick-start section in main README.md.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add graceful shutdown and resource cleanup",
            "description": "Implement proper signal handling and resource cleanup for TTS subsystems",
            "dependencies": [
              "10.1",
              "10.4"
            ],
            "details": "Create pkg/tts/lifecycle.go with cleanup coordination. Implement signal handlers for SIGINT/SIGTERM with graceful TTS shutdown. Add defer cleanup in all engine implementations. Ensure subprocess termination on exit. Implement cache flush on shutdown if configured. Add audio playback interruption handling. Create resource leak detection in debug mode. Ensure all goroutines terminate properly.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Perform cross-platform integration testing",
            "description": "Validate all production features work correctly across Linux, macOS, and Windows",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4",
              "10.5",
              "10.6"
            ],
            "details": "Create integration test suite in tts_integration_test.go. Test timeout protection with slow/hanging processes. Validate dependency detection messages on each platform. Test configuration loading and precedence. Verify graceful shutdown sequences. Test cache behavior across sessions. Validate error messages and recovery paths. Add CI matrix testing for all platforms. Document platform-specific quirks discovered.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-13T19:20:07.954Z",
      "updated": "2025-08-13T22:49:45.396Z",
      "description": "Tasks for master context"
    }
  }
}